{"meta":{"title":"YangMeng'Blog","subtitle":null,"description":" 沉淀、分享、成长~","author":"yangmeng","url":"https://www.itcode.net.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-07-21T20:56:53.647Z","updated":"2023-07-21T19:37:30.469Z","comments":false,"path":"/404.html","permalink":"https://www.itcode.net.cn/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-07-21T20:35:29.042Z","updated":"2023-07-21T19:37:30.470Z","comments":false,"path":"books/index.html","permalink":"https://www.itcode.net.cn/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-07-22T07:06:54.372Z","updated":"2023-07-22T07:06:54.372Z","comments":false,"path":"about/index.html","permalink":"https://www.itcode.net.cn/about/index.html","excerpt":"","text":"🍀 介绍 欢迎光临我的博客，记录回忆的地方🎉 热爱生活，对一切新的事物充满好奇😄 全栈开发，我相信代码改变世界，实际已经改变啦~🌍 💻 技能 语言：Java、C++、Python、JavaScript、TypeScript、NodeJS、Dart等框架：Vue、Uni-app、Koa、Flutter、Cool-admin等其他: Liunx、Ngxin、Docker、MySQL、Git&#x2F;SVN等 🌀 博客 开发技术讨论技巧分享、一起成长 📧关于回复 大家的评论我看到都会在第一时间回复，回复之后，请注意留意收件箱信息！ 🛡️免责声明 本站提供的所有内容仅供学习、交流和分享用途，只供参考、转载请保留署名以及原文链接，谢谢 本站部分资源或者图片源于网络，仅供学习和研究使用。如有侵犯您的版权请 留言或者联系 联系我 删除内容 关于本站的所有留言评论与转载、引用文纯属文字原作者个人观点，与本站观点及立场无关；浏览者在本站发表信息时需要遵守中国现行相应法律，不得发布违法信息"},{"title":"友情链接","date":"2023-07-21T20:56:53.611Z","updated":"2023-07-21T19:37:30.470Z","comments":true,"path":"links/index.html","permalink":"https://www.itcode.net.cn/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-07-26T13:57:06.019Z","updated":"2023-07-26T13:57:06.013Z","comments":false,"path":"categories/index.html","permalink":"https://www.itcode.net.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-07-26T14:00:46.630Z","updated":"2023-07-26T14:00:46.627Z","comments":false,"path":"tags/index.html","permalink":"https://www.itcode.net.cn/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2023-07-29T05:04:17.000Z","updated":"2023-07-29T05:16:18.403Z","comments":false,"path":"schedule/index.html","permalink":"https://www.itcode.net.cn/schedule/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-07-21T20:32:50.322Z","updated":"2023-07-21T19:37:30.470Z","comments":false,"path":"repository/index.html","permalink":"https://www.itcode.net.cn/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"延迟队列","slug":"延迟队列","date":"2023-08-11T13:34:32.000Z","updated":"2023-08-11T15:24:21.585Z","comments":false,"path":"posts/c41f8085/","link":"","permalink":"https://www.itcode.net.cn/posts/c41f8085/","excerpt":"延迟队列说明及实现原理 是一个无阻塞队列（BlockingQueue） 使用完全二叉堆结构 添加元素时，延迟最小的元素放在队首 二叉堆结构是一种完整或近似二叉树的结构，下文以PriorityQueue实现平衡二叉堆结构，数据以队列形式存储。其父子节点关系如下： 父子节点索引关系 父节点为queue[n]，左子节点则为queue[2n+1]，右子节点为queue[2n+2] 任意子节点的父节点位置都是(n-1)&gt;&gt;&gt;1，相当于减1后除2取整 节点间大小关系 父节点小于等于任意子节点 同一层的两个子节点大小不需要维护，仅需在弹出元素时候进行判断 子叶节点与非子叶节点 一个长度为size的优先队列，当index &gt;&#x3D; size &gt;&gt;&gt; 1时，该节点为叶子节点，否则为非叶子节点 入队 出队","text":"延迟队列说明及实现原理 是一个无阻塞队列（BlockingQueue） 使用完全二叉堆结构 添加元素时，延迟最小的元素放在队首 二叉堆结构是一种完整或近似二叉树的结构，下文以PriorityQueue实现平衡二叉堆结构，数据以队列形式存储。其父子节点关系如下： 父子节点索引关系 父节点为queue[n]，左子节点则为queue[2n+1]，右子节点为queue[2n+2] 任意子节点的父节点位置都是(n-1)&gt;&gt;&gt;1，相当于减1后除2取整 节点间大小关系 父节点小于等于任意子节点 同一层的两个子节点大小不需要维护，仅需在弹出元素时候进行判断 子叶节点与非子叶节点 一个长度为size的优先队列，当index &gt;&#x3D; size &gt;&gt;&gt; 1时，该节点为叶子节点，否则为非叶子节点 入队 出队 延迟队列的实现 Queue 单端队列接口 12345678910public interface Queue&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); E poll(); E peek();&#125; Deque 双端队列 12345public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; void addFirst(E e); void addLast(E e);&#125; BlockingQueue 阻塞队列接口 1234public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125; Delayed 延迟队列接口 1234public interface Delayed extends Comparable&lt;Delayed&gt;&#123; long getDelay(TimeUnit unit);&#125; PriorityQueue 优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class PriorityQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Logger logger = LoggerFactory.getLogger(PriorityQueue.class); private static final int DEFAULT_INITIAL_CAPACITY = 11; transient Object[] queue; private int size = 0; public PriorityQueue() &#123; queue = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; @Override public boolean offer(E e) &#123; if (e == null) &#123; throw new NullPointerException(); &#125; int i = size; if (i &gt;= queue.length) &#123; grow(i + 1); &#125; size = i + 1; if (i == 0) &#123; queue[0] = e; &#125; else &#123; siftUp(i, e); &#125; return true; &#125; private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // overflow-conscious code if (newCapacity - (Integer.MAX_VALUE - 8) &gt; 0) &#123; newCapacity = (minCapacity &gt; Integer.MAX_VALUE - 8) ? Integer.MAX_VALUE : Integer.MAX_VALUE - 8; &#125; queue = Arrays.copyOf(queue, newCapacity); &#125; private void siftUp(int k, E x) &#123; siftUpComparable(k, x); &#125; @SuppressWarnings(&quot;unchecked&quot;) private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; logger.info(&quot;【入队】元素：&#123;&#125; 当前队列：&#123;&#125;&quot;, JSON.toJSONString(key), JSON.toJSONString(queue)); while (k &gt; 0) &#123; // 获取父节点Idx，相当于除以2 int parent = (k - 1) &gt;&gt;&gt; 1; logger.info(&quot;【入队】寻找当前节点的父节点位置。k：&#123;&#125; parent：&#123;&#125;&quot;, k, parent); Object e = queue[parent]; // 如果当前位置元素，大于父节点元素，则退出循环 if (key.compareTo((E) e) &gt;= 0) &#123; logger.info(&quot;【入队】值比对，父节点：&#123;&#125; 目标节点：&#123;&#125;&quot;, JSON.toJSONString(e), JSON.toJSONString(key)); break; &#125; // 相反父节点位置大于当前位置元素，则进行替换 logger.info(&quot;【入队】替换过程，父子节点位置替换，继续循环。父节点值：&#123;&#125; 存放到位置：&#123;&#125;&quot;, JSON.toJSONString(e), k); queue[k] = e; k = parent; &#125; queue[k] = key; logger.info(&quot;【入队】完成 Idx：&#123;&#125; Val：&#123;&#125; \\r\\n当前队列：&#123;&#125; \\r\\n&quot;, k, JSON.toJSONString(key), JSON.toJSONString(queue)); &#125; @Override public boolean add(E e) &#123; return offer(e); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public E poll() &#123; if (size == 0) &#123; return null; &#125; int s = --size; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) &#123; siftDown(0, x); &#125; return result; &#125; private void siftDown(int k, E x) &#123; siftDownComparable(k, x); &#125; @SuppressWarnings(&quot;unchecked&quot;) private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; // 先找出中间件节点 int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; // 找到左子节点和右子节点，两个节点进行比较，找出最大的值 int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; // 左子节点与右子节点比较，取最小的节点 if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) &#123; logger.info(&quot;【出队】左右子节点比对，获取最小值。left：&#123;&#125; right：&#123;&#125;&quot;, JSON.toJSONString(c), JSON.toJSONString(queue[right])); c = queue[child = right]; &#125; // 目标值与c比较，当目标值小于c值，退出循环。说明此时目标值所在位置适合，迁移完成。 if (key.compareTo((E) c) &lt;= 0) &#123; break; &#125; // 目标值小于c值，位置替换，继续比较 logger.info(&quot;【出队】替换过程，节点的值比对。上节点：&#123;&#125; 下节点：&#123;&#125; 位置替换&quot;, JSON.toJSONString(queue[k]), JSON.toJSONString(c)); queue[k] = c; k = child; &#125; // 把目标值放到对应位置 logger.info(&quot;【出队】替换结果，最终更换位置。Idx：&#123;&#125; Val：&#123;&#125;&quot;, k, JSON.toJSONString(key)); queue[k] = key; &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public E peek() &#123; return (size == 0) ? null : (E) queue[0]; &#125;&#125; DelayQueue 延迟队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;&#123; private final transient ReentrantLock lock = new ReentrantLock(); private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;&gt;(); private final Condition available = lock.newCondition(); @Override public boolean add(E e) &#123; return offer(e); &#125; @Override public boolean offer(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; q.offer(e); if (q.peek() == e) &#123; available.signal(); &#125; return true; &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; E first = q.peek(); if (first == null || first.getDelay(NANOSECONDS) &gt; 0) &#123; return null; &#125; else &#123; return q.poll(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public E peek() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return q.peek(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 测试代码 QueueTest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class QueueTest &#123; private final Logger logger = LoggerFactory.getLogger(QueueTest.class); @Test public void test_queue() throws InterruptedException &#123; Queue&lt;Job&gt; queue = new DelayQueue&lt;&gt;(); queue.add(new Job(&quot;1号&quot;, 1000L)); queue.add(new Job(&quot;3号&quot;, 3000L)); queue.add(new Job(&quot;5号&quot;, 5000L)); queue.add(new Job(&quot;11号&quot;, 11000L)); queue.add(new Job(&quot;4号&quot;, 4000L)); queue.add(new Job(&quot;6号&quot;, 6000L)); queue.add(new Job(&quot;7号&quot;, 7000L)); queue.add(new Job(&quot;12号&quot;, 12000L)); queue.add(new Job(&quot;15号&quot;, 15000L)); queue.add(new Job(&quot;10号&quot;, 10000L)); queue.add(new Job(&quot;9号&quot;, 9000L)); queue.add(new Job(&quot;8号&quot;, 8000L)); while (true) &#123; Job poll = queue.poll(); if (null == poll) &#123; Thread.sleep(10); continue; &#125; logger.info(poll.getName()); &#125; &#125; static class Job implements Delayed &#123; private final String name; private final Long begin; private final Long delayTime; public Job(String name, Long delayTime) &#123; this.name = name; this.begin = System.currentTimeMillis(); this.delayTime = delayTime;//延时时长 &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(begin + delayTime - System.currentTimeMillis(), TimeUnit.MICROSECONDS); &#125; public String getName() &#123; return name; &#125; @Override public int compareTo(Delayed o) &#123; Job job = (Job) o; return (int) (this.getDelay(TimeUnit.MICROSECONDS) - job.getDelay(TimeUnit.MICROSECONDS)); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"}]},{"title":"手撕Mybatis--实现简单Mybatis框架","slug":"手撕Mybatis--实现简单Mybatis框架","date":"2023-08-10T15:13:29.000Z","updated":"2023-08-11T13:24:52.736Z","comments":false,"path":"posts/35f33c4c/","link":"","permalink":"https://www.itcode.net.cn/posts/35f33c4c/","excerpt":"传统JDBC问题解决思路 使⽤数据库连接池初始化连接资源· 将sql语句抽取到xml配置⽂件中 使⽤反射、内省等底层技术，⾃动将实体与表进⾏属性与字段的⾃动映射 自定义框架设计 使用端 ​ 核⼼配置⽂件，sqlMapConfig.xml：存放数据源信息，引⼊mapper.xml：sql语句的配置⽂件信息 框架端 读取配置⽂件，以流的形式存在，创建javaBean来存储 Configuration : 存放数据库基本信息、Map&lt;唯⼀标识，Mapper&gt; 唯⼀标识：namespace + “.”+ id MappedStatement：sql语句、statement类型、输⼊参数java类型、输出参数java类型 解析配置⽂件 创建sqlSessionFactoryBuilder类： ⽅法：sqlSessionFactory build()：第⼀：使⽤dom4j解析配置⽂件，将解析出来的内容封装到Configuration和MappedStatement中；第⼆：创建SqlSessionFactory的实现类DefaultSqlSession 创建SqlSessionFactory ⽅法：openSession() : 获取sqlSession接⼝的实现类实例对象 创建sqlSession接⼝及实现类：主要封装crud⽅法 ⽅法：selectList(String statementId,Object param)：查询所有； ​ selectOne(String statementId,Object param)：查询单个。 涉及到的设计模式 Builder构建者设计模式 ⼯⼚模式 代理模式 自定义框架的实现创建sqlMapConfig.xml","text":"传统JDBC问题解决思路 使⽤数据库连接池初始化连接资源· 将sql语句抽取到xml配置⽂件中 使⽤反射、内省等底层技术，⾃动将实体与表进⾏属性与字段的⾃动映射 自定义框架设计 使用端 ​ 核⼼配置⽂件，sqlMapConfig.xml：存放数据源信息，引⼊mapper.xml：sql语句的配置⽂件信息 框架端 读取配置⽂件，以流的形式存在，创建javaBean来存储 Configuration : 存放数据库基本信息、Map&lt;唯⼀标识，Mapper&gt; 唯⼀标识：namespace + “.”+ id MappedStatement：sql语句、statement类型、输⼊参数java类型、输出参数java类型 解析配置⽂件 创建sqlSessionFactoryBuilder类： ⽅法：sqlSessionFactory build()：第⼀：使⽤dom4j解析配置⽂件，将解析出来的内容封装到Configuration和MappedStatement中；第⼆：创建SqlSessionFactory的实现类DefaultSqlSession 创建SqlSessionFactory ⽅法：openSession() : 获取sqlSession接⼝的实现类实例对象 创建sqlSession接⼝及实现类：主要封装crud⽅法 ⽅法：selectList(String statementId,Object param)：查询所有； ​ selectOne(String statementId,Object param)：查询单个。 涉及到的设计模式 Builder构建者设计模式 ⼯⼚模式 代理模式 自定义框架的实现创建sqlMapConfig.xml","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.itcode.net.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.itcode.net.cn/tags/Mybatis/"}]},{"title":"手撕Mybatis--分析JDBC操作问题","slug":"手撕Mybatis-分析JDBC操作问题","date":"2023-08-10T14:52:20.000Z","updated":"2023-08-11T12:43:40.057Z","comments":false,"path":"posts/349665f2/","link":"","permalink":"https://www.itcode.net.cn/posts/349665f2/","excerpt":"分析JDBC操作问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123;// 加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding = utf-8&quot;, &quot; root&quot;, &quot;root&quot;);// 定义sql语句？表示占位符 String sql = &quot;select * from user where username = ?&quot;;// 获取预处理statement preparedStatement = connection.prepareStatement(sql);// 设置参数，第⼀个参数为sql语句中参数的序号(从1开始)，第⼆个参数为设置的参数值 preparedStatement.setString(1, &quot;tom&quot;);// 向数据库发出sql执⾏查询，查询出结果集 resultSet = preparedStatement.executeQuery();// 遍历查询结果集 while (resultSet.next()) &#123; int id = resultSet.getInt(&quot;id&quot;); String username = resultSet.getString(&quot;username&quot;);// 封装User// user.setId(id);// user.setUsername(username); &#125; System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;// 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; JDBC问题总结原始jdbc开发存在的问题如下： 数据库连接创建、释放频繁造成系统资源浪费，影响系统性能。 Sql语句在代码中硬编码，不易维护。 使⽤preparedStatement向占有位符号传参数存在硬编码，不易维护。 对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，不易维护。","text":"分析JDBC操作问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123;// 加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);// 通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding = utf-8&quot;, &quot; root&quot;, &quot;root&quot;);// 定义sql语句？表示占位符 String sql = &quot;select * from user where username = ?&quot;;// 获取预处理statement preparedStatement = connection.prepareStatement(sql);// 设置参数，第⼀个参数为sql语句中参数的序号(从1开始)，第⼆个参数为设置的参数值 preparedStatement.setString(1, &quot;tom&quot;);// 向数据库发出sql执⾏查询，查询出结果集 resultSet = preparedStatement.executeQuery();// 遍历查询结果集 while (resultSet.next()) &#123; int id = resultSet.getInt(&quot;id&quot;); String username = resultSet.getString(&quot;username&quot;);// 封装User// user.setId(id);// user.setUsername(username); &#125; System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;// 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; JDBC问题总结原始jdbc开发存在的问题如下： 数据库连接创建、释放频繁造成系统资源浪费，影响系统性能。 Sql语句在代码中硬编码，不易维护。 使⽤preparedStatement向占有位符号传参数存在硬编码，不易维护。 对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，不易维护。","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://www.itcode.net.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.itcode.net.cn/tags/Mybatis/"}]},{"title":"二叉树","slug":"二叉树","date":"2023-08-10T14:14:54.000Z","updated":"2023-08-10T15:26:30.450Z","comments":false,"path":"posts/e85d694a/","link":"","permalink":"https://www.itcode.net.cn/posts/e85d694a/","excerpt":"二叉树实现原理 每个节点最多只有2两个子节点 遍历元素口诀：前序遍历，根-&gt;左-&gt;右、中序遍历，左-&gt;根-&gt;右、后序遍历，左-&gt;右-&gt;根 排序机制：依次从根节点往下比较，小于当前节点值则走左子节点，大于当前节点值则走右子节点，然后用中序遍历 下面对一组数字进行排序：4、2、1、5、3、6，排序机制添加元素（箭头为中序排序顺序），结果如下图 代码实现 Tree 123456public interface Tree&lt;E&gt; &#123; public boolean add(E e); public void sort(List&lt;E&gt; list);&#125; BinaryTreeSort 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class BinaryTreeSort implements Tree&lt;Integer&gt; &#123; // 根节点 private Node&lt;Integer&gt; root; public BinaryTreeSort() &#123; &#125; /** * 依次从根节点往下比较，小于当前节点值则走左子节点，大于当前节点值则走右子节点 */ @Override public boolean add(Integer i) &#123; Node&lt;Integer&gt; node = new Node&lt;&gt;(i); // 根节点不存在 if (root == null) &#123; root = node; return true; &#125; Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i, null, null); Node&lt;Integer&gt; parent = parent(null, i); if (Integer.compare(i, parent.value) == -1) &#123; parent.left = newNode; &#125; else &#123; parent.right = newNode; &#125; return true; &#125; /** * 利用中序遍历来排序 */ @Override public void sort(List&lt;Integer&gt; list) &#123; list.forEach(v -&gt; &#123; add(v); &#125;); List&lt;Integer&gt; sortList = new ArrayList&lt;&gt;(); ldr(root, sortList); System.out.println(&quot;sortList: &quot;+ sortList.stream().map(v -&gt; String.valueOf(v)).collect(Collectors.joining(&quot;,&quot;))); &#125; /** * 递归计算双亲位置 * 当前节点的子节点不存在时，则当前节点为其双亲 */ private Node&lt;Integer&gt; parent(Node&lt;Integer&gt; node, Integer i) &#123; Node&lt;Integer&gt; parent = node == null ? root : node; if (Integer.compare(i, parent.value) == -1) &#123; return parent.left == null ? parent : parent(parent.left, i); &#125; else &#123; return parent.right == null ? parent : parent(parent.right, i); &#125; &#125; /** * 前序遍历，根-&gt;左-&gt;右 */ private void rld(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; sortList.add(node.value); rld(node.left, sortList); rld(node.right, sortList); &#125; &#125; /** * 中序遍历，左-&gt;根-&gt;右 */ private void ldr(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; ldr(node.left, sortList); sortList.add(node.value); ldr(node.right, sortList); &#125; &#125; /** * 后序遍历，左-&gt;右-&gt;根 */ private void lrd(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; lrd(node.left, sortList); lrd(node.right, sortList); sortList.add(node.value); &#125; &#125; /** * 二叉树节点类 */ class Node&lt;E&gt; &#123; // 节点内容 private E value; // 左节点 private Node&lt;E&gt; left; // 右节点 private Node&lt;E&gt; right; public Node() &#123; &#125; public Node(E value) &#123; this.value = value; &#125; public Node(E value, Node&lt;E&gt; left, Node&lt;E&gt; right) &#123; this.value = value; this.left = left; this.right = right; &#125; &#125;&#125; BinaryTreeTest","text":"二叉树实现原理 每个节点最多只有2两个子节点 遍历元素口诀：前序遍历，根-&gt;左-&gt;右、中序遍历，左-&gt;根-&gt;右、后序遍历，左-&gt;右-&gt;根 排序机制：依次从根节点往下比较，小于当前节点值则走左子节点，大于当前节点值则走右子节点，然后用中序遍历 下面对一组数字进行排序：4、2、1、5、3、6，排序机制添加元素（箭头为中序排序顺序），结果如下图 代码实现 Tree 123456public interface Tree&lt;E&gt; &#123; public boolean add(E e); public void sort(List&lt;E&gt; list);&#125; BinaryTreeSort 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class BinaryTreeSort implements Tree&lt;Integer&gt; &#123; // 根节点 private Node&lt;Integer&gt; root; public BinaryTreeSort() &#123; &#125; /** * 依次从根节点往下比较，小于当前节点值则走左子节点，大于当前节点值则走右子节点 */ @Override public boolean add(Integer i) &#123; Node&lt;Integer&gt; node = new Node&lt;&gt;(i); // 根节点不存在 if (root == null) &#123; root = node; return true; &#125; Node&lt;Integer&gt; newNode = new Node&lt;&gt;(i, null, null); Node&lt;Integer&gt; parent = parent(null, i); if (Integer.compare(i, parent.value) == -1) &#123; parent.left = newNode; &#125; else &#123; parent.right = newNode; &#125; return true; &#125; /** * 利用中序遍历来排序 */ @Override public void sort(List&lt;Integer&gt; list) &#123; list.forEach(v -&gt; &#123; add(v); &#125;); List&lt;Integer&gt; sortList = new ArrayList&lt;&gt;(); ldr(root, sortList); System.out.println(&quot;sortList: &quot;+ sortList.stream().map(v -&gt; String.valueOf(v)).collect(Collectors.joining(&quot;,&quot;))); &#125; /** * 递归计算双亲位置 * 当前节点的子节点不存在时，则当前节点为其双亲 */ private Node&lt;Integer&gt; parent(Node&lt;Integer&gt; node, Integer i) &#123; Node&lt;Integer&gt; parent = node == null ? root : node; if (Integer.compare(i, parent.value) == -1) &#123; return parent.left == null ? parent : parent(parent.left, i); &#125; else &#123; return parent.right == null ? parent : parent(parent.right, i); &#125; &#125; /** * 前序遍历，根-&gt;左-&gt;右 */ private void rld(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; sortList.add(node.value); rld(node.left, sortList); rld(node.right, sortList); &#125; &#125; /** * 中序遍历，左-&gt;根-&gt;右 */ private void ldr(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; ldr(node.left, sortList); sortList.add(node.value); ldr(node.right, sortList); &#125; &#125; /** * 后序遍历，左-&gt;右-&gt;根 */ private void lrd(Node&lt;Integer&gt; node, List&lt;Integer&gt; sortList) &#123; if (node != null) &#123; lrd(node.left, sortList); lrd(node.right, sortList); sortList.add(node.value); &#125; &#125; /** * 二叉树节点类 */ class Node&lt;E&gt; &#123; // 节点内容 private E value; // 左节点 private Node&lt;E&gt; left; // 右节点 private Node&lt;E&gt; right; public Node() &#123; &#125; public Node(E value) &#123; this.value = value; &#125; public Node(E value, Node&lt;E&gt; left, Node&lt;E&gt; right) &#123; this.value = value; this.left = left; this.right = right; &#125; &#125;&#125; BinaryTreeTest 1234567public class BinaryTreeTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(4,2,1,5,3,6); BinaryTreeSort binaryTreeSort = new BinaryTreeSort(); binaryTreeSort.sort(list); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"}]},{"title":"循环队列","slug":"循环队列","date":"2023-08-10T11:37:24.000Z","updated":"2023-08-10T13:51:58.637Z","comments":false,"path":"posts/b66774c1/","link":"","permalink":"https://www.itcode.net.cn/posts/b66774c1/","excerpt":"循环队列实现原理 队列长度固定，队列有头部指针（front）、尾部指针(rear)两个指针 每插入一个元素，尾部指针前移一位 每取出一个元素，头部指针前移一位 队列满了之后，取出一个元素，再加入一个元素，尾部指针归零 取元素的个数达到队列最大长度之后，头部指针归零 代码实现 先来个接口类 1234567891011121314151617181920212223public interface Queue&lt;T&gt; &#123; /** * 添加元素 */ boolean push(T t); /** * 取出元素，先进先出 */ T pop(); /** * 判断队列是否已满 */ boolean isFull(); /** * 判断队列是否为空 */ boolean isEmpty();&#125; 再来个抽象类，保证子类自己实现接口 1234567891011121314151617181920212223public abstract class AbstractQueue&lt;T&gt; implements Queue&lt;T&gt; &#123; @Override public boolean push(T t) &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public T pop() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public boolean isFull() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public boolean isEmpty() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125;&#125; 队列实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class CycleQueue&lt;T&gt; extends AbstractQueue&lt;T&gt; implements Queue&lt;T&gt;&#123; // 队列初始化大小 private static final int CAPCAITY = 6; // 队列头 volatile int front; // 队列尾 volatile int rear; // 队列元素 volatile T[] arrays; public CycleQueue() &#123; this.arrays = (T[]) new Object[CAPCAITY]; &#125; /** * 添加元素，队尾下标+1 */ @Override public boolean push(T t) &#123; synchronized (this) &#123; if (!isFull()) &#123; arrays[rear] = t; // 队尾指针+1后的值等于队列容积时，队尾下标重置为0，以实现队列循环使用 if (++rear == CAPCAITY) &#123; rear = 0; &#125; return true; &#125; return false; &#125; &#125; /** * 取出元素，队列头下标+1 */ @Override public T pop() &#123; synchronized (this) &#123; if (!isEmpty()) &#123; System.out.print(&quot;当前数组： &quot;); for (int i=0; i&lt;arrays.length; i++) &#123; System.out.print(arrays[i] + &quot;,&quot;); &#125; System.out.print(&quot; - &quot;); final T cur = arrays[front]; arrays[front] = null; front++; // 队头指针+1后的值等于队列容积时，队头下标重置为0，以实现队列循环使用 if (front == CAPCAITY) &#123; front = 0; &#125; return cur; &#125; return null; &#125; &#125; /** * 判断队列是否满 */ @Override public boolean isFull() &#123; synchronized (this) &#123; return front == rear &amp;&amp; arrays[rear] != null; &#125; &#125; /** * 判断队列是否为空 */ @Override public boolean isEmpty() &#123; synchronized (this) &#123; return front == rear &amp;&amp; arrays[rear] == null; &#125; &#125;&#125;","text":"循环队列实现原理 队列长度固定，队列有头部指针（front）、尾部指针(rear)两个指针 每插入一个元素，尾部指针前移一位 每取出一个元素，头部指针前移一位 队列满了之后，取出一个元素，再加入一个元素，尾部指针归零 取元素的个数达到队列最大长度之后，头部指针归零 代码实现 先来个接口类 1234567891011121314151617181920212223public interface Queue&lt;T&gt; &#123; /** * 添加元素 */ boolean push(T t); /** * 取出元素，先进先出 */ T pop(); /** * 判断队列是否已满 */ boolean isFull(); /** * 判断队列是否为空 */ boolean isEmpty();&#125; 再来个抽象类，保证子类自己实现接口 1234567891011121314151617181920212223public abstract class AbstractQueue&lt;T&gt; implements Queue&lt;T&gt; &#123; @Override public boolean push(T t) &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public T pop() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public boolean isFull() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125; @Override public boolean isEmpty() &#123; throw new UnsupportedOperationException(&quot;不支持的方法&quot;); &#125;&#125; 队列实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class CycleQueue&lt;T&gt; extends AbstractQueue&lt;T&gt; implements Queue&lt;T&gt;&#123; // 队列初始化大小 private static final int CAPCAITY = 6; // 队列头 volatile int front; // 队列尾 volatile int rear; // 队列元素 volatile T[] arrays; public CycleQueue() &#123; this.arrays = (T[]) new Object[CAPCAITY]; &#125; /** * 添加元素，队尾下标+1 */ @Override public boolean push(T t) &#123; synchronized (this) &#123; if (!isFull()) &#123; arrays[rear] = t; // 队尾指针+1后的值等于队列容积时，队尾下标重置为0，以实现队列循环使用 if (++rear == CAPCAITY) &#123; rear = 0; &#125; return true; &#125; return false; &#125; &#125; /** * 取出元素，队列头下标+1 */ @Override public T pop() &#123; synchronized (this) &#123; if (!isEmpty()) &#123; System.out.print(&quot;当前数组： &quot;); for (int i=0; i&lt;arrays.length; i++) &#123; System.out.print(arrays[i] + &quot;,&quot;); &#125; System.out.print(&quot; - &quot;); final T cur = arrays[front]; arrays[front] = null; front++; // 队头指针+1后的值等于队列容积时，队头下标重置为0，以实现队列循环使用 if (front == CAPCAITY) &#123; front = 0; &#125; return cur; &#125; return null; &#125; &#125; /** * 判断队列是否满 */ @Override public boolean isFull() &#123; synchronized (this) &#123; return front == rear &amp;&amp; arrays[rear] != null; &#125; &#125; /** * 判断队列是否为空 */ @Override public boolean isEmpty() &#123; synchronized (this) &#123; return front == rear &amp;&amp; arrays[rear] == null; &#125; &#125;&#125; 生产者（当队列满了之后等待，有元素被取出则继续生产） 1234567891011121314151617181920212223242526272829303132333435//起3个线程类，2个生产者，1一个消费者，生产速度大于消费速度public class PushQueueThread extends Thread&#123; private CycleQueue queue; private String threadName; public PushQueueThread(CycleQueue queue, String threadName) &#123; this.queue = queue; this.threadName = threadName; &#125; @Override public void run() &#123; synchronized (queue) &#123; while (true) &#123; int i = new SecureRandom().nextInt(1000); while (queue.isFull()) &#123; try &#123; System.out.print(threadName + &quot; - 发现队列满了，排队等位中。。。。\\n&quot;); queue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; queue.push(i); System.out.print(threadName + &quot;-放入元素： &quot; + i + &quot;\\n&quot;); try &#123; queue.wait(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 消费者（取出元素之后通知生产者生产） 12345678910111213141516171819202122232425262728293031323334353637383940public class PopQueueThread extends Thread&#123; private CycleQueue queue; private String threadName; public PopQueueThread(CycleQueue queue, String threadName) &#123; this.queue = queue; this.threadName = threadName; &#125; @Override public void run() &#123; synchronized (queue) &#123; while (true) &#123; if (!queue.isEmpty()) &#123; Object o = queue.pop(); System.out.print(threadName + &quot;-取出元素: &quot;+o + &quot;\\n&quot;); try &#123; queue.wait(100); System.out.println(threadName + &quot; - 有空位了，下一位上来吧。。。&quot;); queue.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; try &#123; System.out.print(threadName + &quot; - 发现队列空了，坐等客人上门。。。。\\n&quot;); queue.wait(200); queue.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 测试类 12345678910111213public class CycleQueueTest &#123; public static void main(String[] args) &#123; CycleQueue queue = new CycleQueue(); PushQueueThread pushThread1 = new PushQueueThread(queue, &quot;Push1&quot;); PushQueueThread pushThread2 = new PushQueueThread(queue, &quot;Push2&quot;); PopQueueThread popThread = new PopQueueThread(queue, &quot;Pop1&quot;); pushThread1.start(); pushThread2.start(); popThread.start(); &#125;&#125; 输出结果 1234567891011121314151617181920212223242526272829303132333435363738当前数组： 257,null,null,null,null,null, - Pop1-取出元素: 257Push2-放入元素： 73Push1-放入元素： 307Push2-放入元素： 461Pop1 - 有空位了，下一位上来吧。。。当前数组： null,73,307,461,null,null, - Pop1-取出元素: 73Push1-放入元素： 271Push2-放入元素： 21Push2-放入元素： 351Pop1 - 有空位了，下一位上来吧。。。当前数组： 351,null,307,461,271,21, - Pop1-取出元素: 307Push2-放入元素： 66Push1-放入元素： 557Push1 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 351,66,557,461,271,21, - Pop1-取出元素: 461Push1-放入元素： 924Push2 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 351,66,557,924,271,21, - Pop1-取出元素: 271Push2-放入元素： 170Push1 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 351,66,557,924,170,21, - Pop1-取出元素: 21Push1-放入元素： 189Push2 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 351,66,557,924,170,189, - Pop1-取出元素: 351Push2-放入元素： 964Push1 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 964,66,557,924,170,189, - Pop1-取出元素: 66Push2-放入元素： 490Push1 - 发现队列满了，排队等位中。。。。Pop1 - 有空位了，下一位上来吧。。。当前数组： 964,490,557,924,170,189, - Pop1-取出元素: 557Push1-放入元素： 996Push2 - 发现队列满了，排队等位中。。。。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"}]},{"title":"动态数组","slug":"动态数组","date":"2023-08-10T11:09:49.000Z","updated":"2023-08-11T12:42:40.334Z","comments":false,"path":"posts/3594e15e/","link":"","permalink":"https://www.itcode.net.cn/posts/3594e15e/","excerpt":"动态数组实现原理相较于大家都熟悉的普通数组，动态数组主要体现在两个方面，即数组扩容与数组缩减，综合体现如下： 添加元素 不局限于只在数组末尾添加，而是能够随意选择索引位置(只要不超过数组长度) 删除元素 同添加元素，也可根据索引进行选择 数组扩容 数组一旦装满元素，可触发数组扩容，即新建一个更长的数组，将原数组元素转移到新数组中，并将引用指向新数组，完成数组的变更； 数组缩容 如果数组元素相对总容量来说过少(例如数组元素个数小于数组容量的1&#x2F;4)，便可触发数组缩减，即新建一个更短的数组，并转移元素至新数组。","text":"动态数组实现原理相较于大家都熟悉的普通数组，动态数组主要体现在两个方面，即数组扩容与数组缩减，综合体现如下： 添加元素 不局限于只在数组末尾添加，而是能够随意选择索引位置(只要不超过数组长度) 删除元素 同添加元素，也可根据索引进行选择 数组扩容 数组一旦装满元素，可触发数组扩容，即新建一个更长的数组，将原数组元素转移到新数组中，并将引用指向新数组，完成数组的变更； 数组缩容 如果数组元素相对总容量来说过少(例如数组元素个数小于数组容量的1&#x2F;4)，便可触发数组缩减，即新建一个更短的数组，并转移元素至新数组。 代码实现 Array 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class Array&lt;E&gt; &#123; private E[] data; // 使用静态数组存放数组元素 private int size; // 记录数组元素数量 public Array(int capacity) &#123; this.data = (E[]) new Object[capacity]; this.size = 0; &#125; public int getSize() &#123; return size; &#125; public Array() &#123; this(10); // 默认capacity为10 &#125; // 数组扩容/缩减 public void resize(int newCapacity) &#123; // 新数组长度必须大于0 if (newCapacity &lt; 0) &#123; throw new IllegalArgumentException(&quot;capacity must &gt; 0!&quot;); &#125; // 创建新数组 E[] newData = (E[]) new Object[newCapacity]; // 将原数组元素放入新数组中 for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; // 将引用指向新数组 data = newData; &#125; /** * 在指定位置添加元素 * 指定位置处的元素需要向右侧移动一个单位 * @param index 索引 * @param element 要添加的元素 */ public void add(int index, E element) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(&quot;Illegal index, index must &gt; 0 and &lt;= size!&quot;); &#125; // 数组满员触发扩容 if (size == data.length) &#123; resize(2 * data.length); // 扩容为原数组的2倍 &#125; // 从尾部开始，向右移动元素，直到index for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; // 添加元素 data[index] = element; size++; &#125; // 数组头部添加元素 public void addFirst(E element) &#123; add(0, element); &#125; // 数组尾部添加元素 public void addLast(E element) &#123; add(size, element); &#125; /** * 删除指定位置元素 * 通过向左移动一位，覆盖指定位置处的元素，实现删除元素(data[size - 1] = null) * @param index 索引 */ public E remove(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(&quot;Illegal index, index must &gt; 0 and &lt; size!&quot;); &#125; // 数组长度为0时抛出异常 if (size == 0) &#123; throw new IllegalArgumentException(&quot;Empty array!&quot;); &#125; E removedElement = data[index]; // 向左移动元素 for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i + 1]; &#125; // 将尾部空闲出的位置置为空，释放资源 data[size - 1] = null; size--; // size过小触发数组缩减 if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return removedElement; &#125; // 删除头部元素 public E removeFirst() &#123; return remove(0); &#125; // 删除尾部元素 public E removeLast() &#123; return remove(size - 1); &#125; // 重写Override方法，自定义数组显示格式 @Override public String toString() &#123; StringBuilder str = new StringBuilder(); // 显示数组的整体情况(长度、总容量) str.append(String.format(&quot;Array: size = %d, capacity = %d\\n[&quot;, size, data.length)); // 循环添加数组元素至str for (int i = 0; i &lt; size; i++) &#123; str.append(data[i]); if (i &lt; size - 1) &#123; str.append(&quot;, &quot;); &#125; &#125; str.append(&quot;]&quot;); return str.toString(); &#125;&#125; ArrayTest 123456789101112131415161718192021public class ArrayTest &#123; public static void main(String[] args) &#123; // 添加10个元素 Array&lt;Integer&gt; arr = new Array&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; arr.add(i, i); &#125; // 查看数组当前状态 System.out.println(arr); // 继续添加元素，观察是否扩容 arr.add(arr.getSize(), 7); System.out.println(arr); // 再删除6个元素，观察是否缩减 for (int i = 0; i &lt; 6; i++) &#123; System.out.println(&quot;元素&quot; + arr.removeFirst() + &quot;已被删除！&quot;); &#125; System.out.println(arr); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"}]},{"title":"链表","slug":"链表","date":"2023-08-08T14:51:22.000Z","updated":"2023-08-11T12:41:52.001Z","comments":true,"path":"posts/2362a8ea/","link":"","permalink":"https://www.itcode.net.cn/posts/2362a8ea/","excerpt":"链表的定义是一种数据结构，通过指针连接数据项，提供了一些灵活的操作。 优点 高效插入和删除 缺点 查询时间复杂度高 单向链表单链表包含具有数据字段的节点以及指向节点行中的下一个节点的“下一个”字段。 双向链表在“双向链表”中，除了下一个节点链接之外，每个节点还包含指向序列中“前一个”节点的第二个链接字段。 循环链表","text":"链表的定义是一种数据结构，通过指针连接数据项，提供了一些灵活的操作。 优点 高效插入和删除 缺点 查询时间复杂度高 单向链表单链表包含具有数据字段的节点以及指向节点行中的下一个节点的“下一个”字段。 双向链表在“双向链表”中，除了下一个节点链接之外，每个节点还包含指向序列中“前一个”节点的第二个链接字段。 循环链表在列表的最后一个节点中，链接字段通常包含一个空引用，一个特殊的值用于指示缺少进一步的节点。一个不太常见的约定是让它指向列表的第一个节点。在这种情况下，列表被称为“循环”或“循环链接”；否则，它被称为“开放”或“线性”。它是一个列表，其中最后一个指针指向第一个节点。 实现一个双向链表 链表节点 123456789101112131415161718192021private class Node&lt;E&gt;&#123; //当前节点元素 E value; //上一个节点 Node&lt;E&gt; prev; //下一个节点 Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next)&#123; this.value = value; this.next = next; &#125; public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)&#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; 头插节点 123456789101112131415/** * 往头部添加节点 * @param e 元素 */ private void linkBefore(E e) &#123; final Node&lt;E&gt; temp = first; Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, temp); if (temp == null)&#123; last = newNode; &#125;else &#123; temp.prev = newNode; &#125; first = newNode; size++; &#125; 尾插节点 1234567891011121314151617/** * 往尾部添加节点 * @param e 元素 */ private void linkLast(E e) &#123; final Node&lt;E&gt; temp = last; //新节点成为尾部节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(temp, e, null); last = newNode; //如果原来尾部节点为空，则为第一个节点 if (temp == null)&#123; first = newNode; &#125;else &#123; temp.next = newNode; &#125; size++; &#125; 检查下标是否越界 123456//检查下标是否越界 private void checkIndex(int index)&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(&quot;下标越界：index &lt; 0 || index &gt;= size&quot;); &#125; &#125; 获取下标位置节点 123456789101112131415161718192021/** * 获取下标位置的节点 * @param index * @return */private Node&lt;E&gt; node(int index)&#123; int half = size &gt;&gt; 1; //下标小于链表长度一半，从头开始找，否则,从尾部开始找 Node&lt;E&gt; cur; if(index &lt; half)&#123; cur = first; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; &#125;else&#123; cur = last; for(int i = (size - 1); i &gt; index; i--)&#123; cur = last.prev; &#125; &#125; return cur; &#125; 删除节点 12345678910111213141516/** * 移除下标位置的节点 * @param index * @return */@Override public E remove(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); if(cur.prev == null)&#123; first =cur.next; &#125;else &#123; cur.prev.next = cur.next; &#125; size--; return cur.value; &#125; 完整代码 LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; &#123; //链表长度 transient int size; //头部节点 transient Node&lt;E&gt; first; //尾部节点 transient Node&lt;E&gt; last; @Override public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; @Override public int size() &#123; return this.size; &#125; //在尾部添加（默认） @Override public boolean add(E e)&#123; linkLast(e); return true; &#125; //在头部添加 public boolean addFirst(E e)&#123; linkBefore(e); return true; &#125; //查找下标位置的节点 @Override public E get(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); return cur.value; &#125; /** * 移除下标位置的节点 * @param index * @return */ @Override public E remove(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); if(cur.prev == null)&#123; first =cur.next; &#125;else &#123; cur.prev.next = cur.next; &#125; size--; return cur.value; &#125; /** * 往头部添加节点 * @param e 元素 */ private void linkBefore(E e) &#123; final Node&lt;E&gt; temp = first; Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, temp); if (temp == null)&#123; last = newNode; &#125;else &#123; temp.prev = newNode; &#125; first = newNode; size++; &#125; /** * 往尾部添加节点 * @param e 元素 */ private void linkLast(E e) &#123; final Node&lt;E&gt; temp = last; //新节点成为尾部节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(temp, e, null); last = newNode; //如果原来尾部节点为空，则为第一个节点 if (temp == null)&#123; first = newNode; &#125;else &#123; temp.next = newNode; &#125; size++; &#125; /** * 获取下标位置的节点 * @param index * @return */ private Node&lt;E&gt; node(int index)&#123; int half = size &gt;&gt; 1; //下标小于链表长度一半，从头开始找，否则,从尾部开始找 Node&lt;E&gt; cur; if(index &lt; half)&#123; cur = first; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; &#125;else&#123; cur = last; for(int i = (size - 1); i &gt; index; i--)&#123; cur = last.prev; &#125; &#125; return cur; &#125; //检查下标是否越界 private void checkIndex(int index)&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(&quot;下标越界：index &lt; 0 || index &gt;= size&quot;); &#125; &#125; //内部内节点 private class Node&lt;E&gt;&#123; //当前节点元素 E value; //上一个节点 Node&lt;E&gt; prev; //下一个节点 Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next)&#123; this.value = value; this.next = next; &#125; public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)&#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; /** * 重写迭代器，实现迭代遍历元素 */ private class ListItr implements ListIterator&lt;E&gt;&#123; //上一个节点 private Node&lt;E&gt; lastReturned; //下一个节点 private Node&lt;E&gt; next; //下一个节点下标 private int nextIndex; public ListItr(int index) &#123; next = (index == size) ? null : node(index); nextIndex = index; &#125; @Override public boolean hasNext() &#123; return nextIndex &lt; size; &#125; @Override public E next() &#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; lastReturned = next; next = next.next; nextIndex++; return lastReturned.value; &#125; @Override public boolean hasPrevious() &#123; return false; &#125; @Override public E previous() &#123; return null; &#125; @Override public int nextIndex() &#123; return nextIndex; &#125; @Override public int previousIndex() &#123; return 0; &#125; @Override public void remove() &#123; &#125; @Override public void set(E e) &#123; &#125; @Override public void add(E e) &#123; &#125; &#125; &#125; LinkedListTest1234567891011121314151617181920212223242526public class LinkedListTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;计时开始：&quot; + LocalDateTime.now()); LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i=1; i&lt;9; i++) &#123; list.add(i); &#125; System.out.println(&quot;计时结束：&quot; + LocalDateTime.now()); list.addFirst(9); list.add(80); print(list); &#125; public static void print(LinkedList&lt;Integer&gt; list) &#123; for (Object i : list) &#123; System.out.print(i); System.out.print(&quot;,&quot;); &#125; System.out.println(); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-07-26T12:35:13.000Z","updated":"2023-07-29T10:00:11.712Z","comments":true,"path":"posts/d0edc1ed/","link":"","permalink":"https://www.itcode.net.cn/posts/d0edc1ed/","excerpt":"目录与文件 more 12more [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 less 123less [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 head 12345head [OPTION]… FILE…显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行：$ head -5 file1 tail 1234tail [OPTION]… FILE…显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行：$ tail -5 file1 ln","text":"目录与文件 more 12more [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 less 123less [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 head 12345head [OPTION]… FILE…显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行：$ head -5 file1 tail 1234tail [OPTION]… FILE…显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行：$ tail -5 file1 ln 1234567891011链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（SymbolicLink）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。举例如下，注意ls -l列出文件的硬链接数和字节数：硬链接：touch helloln hello word_h软链接：ln -s hello word_s tree 123这个命令需要下载安装，ubuntu下sudo apt-get install tree按结构树的形状显示目录和文件 wc 12345678利用wc 指令我们可以计算文件的Byte 数、字数、或是列数,若不指定文件名称、或是所给予的文件名为“-”,则wc 指令会从标准输入设备读取数据。wc -l ./*-c 或–bytes 或–chars 只显示Bytes 数。-l 或–lines 只显示列数。-w 或–words 只显示字数。 du 123456789查看某个目录的大小：以M为单位du -hm /home/itcast/test以B为单位du -hb ./*以K为单位,4k的整数倍du -hk ./*总计大小，以M为单位du -hc ./* df 123df查看磁盘使用情况df --block-size=GBdf --block-size=MB 文件属性与用户组 chmod 12345678910111213141516171819202122232425262728293031文字设定法chmod [who] [+|-|=] [mode] 文件名操作对象who可是下述字母中的任一个或者它们的组合：u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。操作符号可以是：+ 添加某个权限。- 取消某个权限。= 赋予给定权限并取消其他所有权限（如果有的话）。设置mode所表示的权限可用下述字母的任意组合：r 可读。w 可写。x 可执行。数字设定法chmod [mode] 文件名0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，user group otherr w x r w x r w x4 2 1 4 2 1 4 2 1 chown 123456789101112131415161718chown [OPTION]… [OWNER:GROUP] FILE…chown [OPTION]… –reference=RFILE FILE…更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户A, 为了让用户A能够存取这个文件，root用户应该把这个文件的属主设为A，否则，用户A无法存取这个文件。OPTION的主要参数：* -R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。* -v 显示chown命令所做的工作。比如把一个文件改为itcast用户和nogroup用户组所有$ sudo chown itcast:nogroup file1注意：* chown需要特权用户才能执行* 一个文件的owner和owning group是没有关联的。一个文件属于用户A，也属于用户组B，并不表示用户A属于用户组B。 chgrp 123456789chgrp [OPTION]… GROUP FILE…chgrp [OPTION]… –reference=RFILE FILE…该命令改变（指定）指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。OPTION的主要参数：-R 递归式地改变指定目录及其下的所有子目录和文件的属组。 查找与检索 find 12345678910111213根据文件名查找find pathname -options [-print -exec -ok -name -type...]在目录中搜索文件，path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。Expression 是find命令接受的表达式，find命令的所有操作都是针对表达式的。一条最常用的find命令－－在当前目录及子目录下查找所有以file开头的文件名。$ find . -name &#x27;file*&#x27;$ find / -name &#x27;vimrc&#x27;$ find ~ -name &#x27;*.c&#x27;$ find /usr/ -name &quot;*tmp*&quot; -exec ls -l &#123; &#125; \\;find ./ -name &quot;*tmp&quot; -ok rm &#123; &#125; \\; grep 1234567891011121314151617根据内容检索grep [options] PATTERN [FILE...]在指定文件中搜索特定的内容，并将含有这些内容的行输出到标准输出。若不指定文件名，则从标准输入读取。[options]部分包含的主要参数：-I：不区分大小写（只适用于单字符）。-h：查询多文件时不显示文件名。-l：查询多文件时只输出包含匹配字符的文件名。-n：显示匹配行及行号。-s：不显示不存在或无匹配文本的错误信息。-v：显示不包含匹配文本的所有行。-R: 连同子目录中所有文件一起查找。比如到系统头文件目录下查找所有包含printf的文件$ grep &#x27;printf&#x27; /usr/include -R 安装卸载软件 更新源服务器列表 1sudo vi /etc/apt/sources.list 更新完服务器列表后需要更新下源 12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 deb包安装 1234567安装deb软件包命令： sudo dpkg -i xxx.deb删除软件包命令： sudo dpkg -r xxx.deb连同配置文件一起删除命令： sudo dpkg -r --purge xxx.deb查看软件包信息命令： sudo dpkg -info xxx.deb查看文件拷贝详情命令： sudo dpkg -L xxx.deb查看系统中已安装软件包信息命令： sudo dpkg -l重新配置软件包命令： sudo dpkg-reconfigure xxx 源码安装 123456789101. 解压缩源代码包2. cd dir3. ./configure检测文件是否缺失，创建Makefile,检测编译环境4. make编译源码，生成库和可执行程序5. sudo make install把库和可执行程序，安装到系统路径下6. sudo make distclean删除和卸载软件 磁盘管理 mount 123456789101112131415161718192021命令格式：mount [-t vfstype] -o options device dir其中：* -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfs* -o options 主要用来描述设备或档案的挂接方式。常用的参数有：loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备iocharset：指定访问文件系统所用字符集* device 要挂接(mount)的设备。* dir设备在系统上的挂接点(mount point)。 挂接光盘镜像文件 1.从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。 12345#cp /dev/cdrom /home/sunky/mydisk.iso 或#dd if=/dev/cdrom of=/home/sunky/mydisk.iso注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso 2.文件和目录制作成光盘镜像文件，执行下面的命令。 1#mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir ​ 注：这条命令将&#x2F;home&#x2F;sunky&#x2F;mydir目录下所有的目录和文件制作成光盘镜像文件&#x2F;home&#x2F;sunky&#x2F;mydisk.iso，光盘卷标为：mydisk 123456789-r 这个选项能够将文件的uid,gid设为0，因为uid与gid只在制作镜像者本身系统上有效，在其它电脑上没有对应的用户，所以留着也只是无效用户；将所有文件设置为可读。如果文件有可执行的权限的话，将继续保持其可执行的权限。去掉所有文件及文件夹可写权限，因为挂载的光盘镜像本身也就为只读系统，可写权限无意义。其它特殊权限都将被清空。-o 指定被创建的镜像文件名称(包含目录位置)-V 指定光盘标签，就像windows下面挂载系统盘时会显示系统盘的名字一样。-J 或-joliet选项表示使用Joliet格式(可使用unicode储存中文档名）由于在ISO 9660中有一些限制，如字符设置限制,文件名长度限制和目录树深度制。这些规定阻碍了用户复制数据，Joliet是ISO 9660的一个扩展，由Microsoft提出和实现。 3.光盘镜像文件的挂接(mount) 1mkisofs -r -J -V mydisk -o /home/itcast/mydisk.iso /home/itcast/object/ ​ 将&#x2F;home&#x2F;itcast&#x2F;object&#x2F;目录下的内容生成一个叫mydisk.iso的镜像文件保存在目录&#x2F; home&#x2F;itcast&#x2F;下。 1#mkdir /mnt/vcdrom ​ 注：建立一个目录用来作挂接点(mount point) 1#mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom ​ 注：使用&#x2F;mnt&#x2F;vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。 挂载U盘磁盘设备命名一般规则： 在Linux中，设备名称通常都保存在&#x2F;dev里，&#x2F;dev下的文件是特殊的设备文件，和特定 的驱动程序相关联。而这些设备的命名有一定的规则，可以使用“推理”方式把设备名称找 出来。 例如：&#x2F;dev&#x2F; sda1，“sd”是SCSI Device (hd是Hard Disk硬盘，fd是Floppy Disk 软盘)。其中“a”代表第一块硬盘，如果主机上装有4块硬盘，那么他们应该依次编号 sda、sdb、sdc、sdd。而sda1中的“1”代表sda的第一个主分区，sda2代表第二个主分区。 由于一块硬盘的主分区最多允许有4个，因此扩展分区的第一个逻辑分区从sda5开始向后依 次编号。 1.检测存储设备名称 1sudo fdisk -l 2.挂载存储设备sdb1到挂载点&#x2F;mnt目录 12sudo mount /dev/sdb1 /mnt -o utf8可以使U盘内的中文正常显示出来。 3.访问&#x2F;mnt 4.卸载&#x2F;mnt 1sudo umount /mnt umount卸载命令 1sudo umount 挂在点 dddd:拷贝 例1：拷贝光碟(注意，你的光碟是标准的iso9660格式才可以这么做唷！) 1dd if=/dev/cdrom of=cdrom.iso 例2：将文件sfile拷贝到文件dfile中。 1$ dd if=sfile of=dfile 例3：创建一个100M的空文件 1dd if=/dev/zero of=hello.txt bs=100M count=1 &#x2F;dev&#x2F;null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ &#x2F;dev&#x2F;zero,是一个输入设备，你可你用它来初始化文件,从里面读出来的数据都是0。 使用mke2fs命令将常规文件格式化成分区当成文件系统来使用，使用mount借助loop设 备把映像文件当成磁盘分区挂载。 1.以&#x2F;dev&#x2F;zero为输入文件，imagefile为输出创建一个2M大小的文件 1$dd if=/dev/zero of=imagefile bs=2048 count=1024 2.使用mke2fs命令将该文件制作成文件系统。制作期间需输入“y”确认。 1$mke2fs imagefile 3.制作成功后可以将该文件使用mount命令借助loop挂载到&#x2F;mnt下 1$sudo mount -o loop imagefile /mnt 4.可以查看到lost+found缺省目录 1$ls /mnt 5.可以像使用普通磁盘一样，直接在里面创建文件并写入内容。 1$sudo vi hello.c 6.lost+found hello.c 1$ls /mnt 7.在&#x2F;mnt内执行mount命令可以查看该“文件系统”的详细信息。 12$mount如：/home/itcast/mydisk on /mnt type ext2 (rw) 8.可使用umount命令将该“磁盘”卸载。 1$sudo umount /mnt","categories":[{"name":"服务器","slug":"服务器","permalink":"https://www.itcode.net.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.itcode.net.cn/tags/Linux/"}]},{"title":"MAC（M1）配置51单片机环境","slug":"MAC（M1）配置51单片机环境","date":"2023-07-25T14:58:29.000Z","updated":"2023-08-10T11:05:32.479Z","comments":true,"path":"posts/cdcb5503/","link":"","permalink":"https://www.itcode.net.cn/posts/cdcb5503/","excerpt":"安装Rosetta21/usr/sbin/softwareupdate --install-rosetta --agree-to-license 安装Homebrew使用Rosetta2安装Homebrew 123arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;#在安装或更新应用时使用下面的命令即可：arch -x86_64 brew install &lt;package&gt; 编译器sdcc1234arch -x86_64 brew install sdcc#校验是否安装成功sdcc -version 安装CH341驱动为让开发版上的USB转串口模块成功连接到Mac上，我们需要CH341驱动来为Mac系统驱动 下载地址：http://www.wch.cn/download/CH341SER_MAC_ZIP.html","text":"安装Rosetta21/usr/sbin/softwareupdate --install-rosetta --agree-to-license 安装Homebrew使用Rosetta2安装Homebrew 123arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;#在安装或更新应用时使用下面的命令即可：arch -x86_64 brew install &lt;package&gt; 编译器sdcc1234arch -x86_64 brew install sdcc#校验是否安装成功sdcc -version 安装CH341驱动为让开发版上的USB转串口模块成功连接到Mac上，我们需要CH341驱动来为Mac系统驱动 下载地址：http://www.wch.cn/download/CH341SER_MAC_ZIP.html 下载好后将文件解压双击.pkg结尾的文件开始安装，一直点下一步即可完成安装 接下来将单片机连接到Mac上（我使用的是STC89型号的），输入一下命令来检验驱动是否安装成功 1ls /dev/tty.wchusbser* 如果输出一下数据，说明驱动成功 注意⚠️：其中140代表串口号 安装烧录程序stcgal stcgal 是 STC 单片机的下载工具，安装前需确保已提前安装好 python3。 下载stcgal地址： https://github.com/grigorig/stcgal 直接下载源码，解压文件即可，再在终端中cd命令进入解压文件夹（一直按tab键来补全路经） 输入以下两行代码即可安装 12345./setup.py buildsudo ./setup.py install#检测版本信息stcgal -V 调试单片机输入代码在编译器上输入以下代码来用数码管点亮SSPAL（编译器我使用的是CLion），将代码以main.c的保存在桌面上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;8051.h&gt;unsigned char Table[] = &#123;0x6D,0x73,0x77,0x30&#125;; //对应SPAI四个字母void Delay(unsigned int x) //@11.0592MHz下延迟1ms&#123; unsigned char i, j; while(x--) &#123; i = 2; j = 199; do &#123; while (--j); &#125; while (--i); &#125;&#125;void Turn_ON(unsigned int Location ,unsigned int Num1) //点亮&#123; switch(Location) //片选 &#123; case 1:P2_4=1;P2_3=1;P2_2=1;break; case 2:P2_4=1;P2_3=1;P2_2=0;break; case 3:P2_4=1;P2_3=0;P2_2=1;break; case 4:P2_4=1;P2_3=0;P2_2=0;break; case 5:P2_4=0;P2_3=1;P2_2=1;break; case 6:P2_4=0;P2_3=1;P2_2=0;break; case 7:P2_4=0;P2_3=0;P2_2=1;break; case 8:P2_4=0;P2_3=0;P2_2=0;break; &#125; P0=Table[Num1]; //段选 Delay(1); P0=0x00;&#125;void main() //主函数&#123; while(1) &#123; Turn_ON(1,0); Turn_ON(2,0); Turn_ON(3,1); Turn_ON(4,2); Turn_ON(5,3); &#125;&#125; 使用sdcc进行编译 使用终端进入到代码的所在目录下，输入以下代码 1sdcc main.c 就可以发现文件夹中多出了一系列文件 使用stcgal将代码烧录入单片机中 输入以下代码 1stcgal -P stc89 -p /dev/tty.wchusbserial140 -P后参数表示单片机型号，例如我的是STC89，-p后参数表示单片机串口号 注意⚠️：在执行stcgal命令，需要给单片机断电再重新接电才能完成写入过程 点亮了单片机上的SSPAL！","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.itcode.net.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://www.itcode.net.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码分析","slug":"源码分析","permalink":"https://www.itcode.net.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"服务器","slug":"服务器","permalink":"https://www.itcode.net.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.itcode.net.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"https://www.itcode.net.cn/tags/algorithms/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.itcode.net.cn/tags/Mybatis/"},{"name":"Linux","slug":"Linux","permalink":"https://www.itcode.net.cn/tags/Linux/"},{"name":"单片机","slug":"单片机","permalink":"https://www.itcode.net.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]}