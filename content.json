{"meta":{"title":"YangMeng'Blog","subtitle":null,"description":" 沉淀、分享、成长~","author":"yangmeng","url":"https://www.itcode.net.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-07-21T20:56:53.647Z","updated":"2023-07-21T19:37:30.469Z","comments":false,"path":"/404.html","permalink":"https://www.itcode.net.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-07-22T07:06:54.372Z","updated":"2023-07-22T07:06:54.372Z","comments":false,"path":"about/index.html","permalink":"https://www.itcode.net.cn/about/index.html","excerpt":"","text":"🍀 介绍 欢迎光临我的博客，记录回忆的地方🎉 热爱生活，对一切新的事物充满好奇😄 全栈开发，我相信代码改变世界，实际已经改变啦~🌍 💻 技能 语言：Java、C++、Python、JavaScript、TypeScript、NodeJS、Dart等框架：Vue、Uni-app、Koa、Flutter、Cool-admin等其他: Liunx、Ngxin、Docker、MySQL、Git&#x2F;SVN等 🌀 博客 开发技术讨论技巧分享、一起成长 📧关于回复 大家的评论我看到都会在第一时间回复，回复之后，请注意留意收件箱信息！ 🛡️免责声明 本站提供的所有内容仅供学习、交流和分享用途，只供参考、转载请保留署名以及原文链接，谢谢 本站部分资源或者图片源于网络，仅供学习和研究使用。如有侵犯您的版权请 留言或者联系 联系我 删除内容 关于本站的所有留言评论与转载、引用文纯属文字原作者个人观点，与本站观点及立场无关；浏览者在本站发表信息时需要遵守中国现行相应法律，不得发布违法信息"},{"title":"书单","date":"2023-07-21T20:35:29.042Z","updated":"2023-07-21T19:37:30.470Z","comments":false,"path":"books/index.html","permalink":"https://www.itcode.net.cn/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-21T20:56:53.611Z","updated":"2023-07-21T19:37:30.470Z","comments":true,"path":"links/index.html","permalink":"https://www.itcode.net.cn/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-07-26T14:00:46.630Z","updated":"2023-07-26T14:00:46.627Z","comments":false,"path":"tags/index.html","permalink":"https://www.itcode.net.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-07-26T13:57:06.019Z","updated":"2023-07-26T13:57:06.013Z","comments":false,"path":"categories/index.html","permalink":"https://www.itcode.net.cn/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2023-07-29T05:04:17.000Z","updated":"2023-07-29T05:16:18.403Z","comments":false,"path":"schedule/index.html","permalink":"https://www.itcode.net.cn/schedule/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-07-21T20:32:50.322Z","updated":"2023-07-21T19:37:30.470Z","comments":false,"path":"repository/index.html","permalink":"https://www.itcode.net.cn/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"近期待办","slug":"近期待办","date":"2023-08-08T15:07:48.000Z","updated":"2023-08-08T15:09:38.621Z","comments":false,"path":"posts/b5de2365/","link":"","permalink":"https://www.itcode.net.cn/posts/b5de2365/","excerpt":"重撸数据结构 刷算法 系统集成项目管理工程 C++","text":"重撸数据结构 刷算法 系统集成项目管理工程 C++","categories":[{"name":"规划","slug":"规划","permalink":"https://www.itcode.net.cn/categories/%E8%A7%84%E5%88%92/"}],"tags":[]},{"title":"链表","slug":"链表","date":"2023-08-08T14:51:22.000Z","updated":"2023-08-08T15:05:56.250Z","comments":true,"path":"posts/2362a8ea/","link":"","permalink":"https://www.itcode.net.cn/posts/2362a8ea/","excerpt":"链表的定义是一种数据结构，通过指针连接数据项，提供了一些灵活的操作。 优点 高效插入和删除 缺点 查询时间复杂度高 单向链表单链表包含具有数据字段的节点以及指向节点行中的下一个节点的“下一个”字段。 双向链表在“双向链表”中，除了下一个节点链接之外，每个节点还包含指向序列中“前一个”节点的第二个链接字段。 循环链表","text":"链表的定义是一种数据结构，通过指针连接数据项，提供了一些灵活的操作。 优点 高效插入和删除 缺点 查询时间复杂度高 单向链表单链表包含具有数据字段的节点以及指向节点行中的下一个节点的“下一个”字段。 双向链表在“双向链表”中，除了下一个节点链接之外，每个节点还包含指向序列中“前一个”节点的第二个链接字段。 循环链表在列表的最后一个节点中，链接字段通常包含一个空引用，一个特殊的值用于指示缺少进一步的节点。一个不太常见的约定是让它指向列表的第一个节点。在这种情况下，列表被称为“循环”或“循环链接”；否则，它被称为“开放”或“线性”。它是一个列表，其中最后一个指针指向第一个节点。 实现一个链表 链表节点 123456789101112131415161718192021private class Node&lt;E&gt;&#123; //当前节点元素 E value; //上一个节点 Node&lt;E&gt; prev; //下一个节点 Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next)&#123; this.value = value; this.next = next; &#125; public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)&#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; 头插节点 123456789101112131415/** * 往头部添加节点 * @param e 元素 */ private void linkBefore(E e) &#123; final Node&lt;E&gt; temp = first; Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, temp); if (temp == null)&#123; last = newNode; &#125;else &#123; temp.prev = newNode; &#125; first = newNode; size++; &#125; 尾插节点 1234567891011121314151617/** * 往尾部添加节点 * @param e 元素 */ private void linkLast(E e) &#123; final Node&lt;E&gt; temp = last; //新节点成为尾部节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(temp, e, null); last = newNode; //如果原来尾部节点为空，则为第一个节点 if (temp == null)&#123; first = newNode; &#125;else &#123; temp.next = newNode; &#125; size++; &#125; 检查下标是否越界 123456//检查下标是否越界 private void checkIndex(int index)&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(&quot;下标越界：index &lt; 0 || index &gt;= size&quot;); &#125; &#125; 获取下标位置节点 123456789101112131415161718192021/** * 获取下标位置的节点 * @param index * @return */private Node&lt;E&gt; node(int index)&#123; int half = size &gt;&gt; 1; //下标小于链表长度一半，从头开始找，否则,从尾部开始找 Node&lt;E&gt; cur; if(index &lt; half)&#123; cur = first; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; &#125;else&#123; cur = last; for(int i = (size - 1); i &gt; index; i--)&#123; cur = last.prev; &#125; &#125; return cur; &#125; 删除节点 12345678910111213141516/** * 移除下标位置的节点 * @param index * @return */@Override public E remove(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); if(cur.prev == null)&#123; first =cur.next; &#125;else &#123; cur.prev.next = cur.next; &#125; size--; return cur.value; &#125; 完整代码 LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; &#123; //链表长度 transient int size; //头部节点 transient Node&lt;E&gt; first; //尾部节点 transient Node&lt;E&gt; last; @Override public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; @Override public int size() &#123; return this.size; &#125; //在尾部添加（默认） @Override public boolean add(E e)&#123; linkLast(e); return true; &#125; //在头部添加 public boolean addFirst(E e)&#123; linkBefore(e); return true; &#125; //查找下标位置的节点 @Override public E get(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); return cur.value; &#125; /** * 移除下标位置的节点 * @param index * @return */ @Override public E remove(int index)&#123; checkIndex(index); Node&lt;E&gt; cur = node(index); if(cur.prev == null)&#123; first =cur.next; &#125;else &#123; cur.prev.next = cur.next; &#125; size--; return cur.value; &#125; /** * 往头部添加节点 * @param e 元素 */ private void linkBefore(E e) &#123; final Node&lt;E&gt; temp = first; Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, temp); if (temp == null)&#123; last = newNode; &#125;else &#123; temp.prev = newNode; &#125; first = newNode; size++; &#125; /** * 往尾部添加节点 * @param e 元素 */ private void linkLast(E e) &#123; final Node&lt;E&gt; temp = last; //新节点成为尾部节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(temp, e, null); last = newNode; //如果原来尾部节点为空，则为第一个节点 if (temp == null)&#123; first = newNode; &#125;else &#123; temp.next = newNode; &#125; size++; &#125; /** * 获取下标位置的节点 * @param index * @return */ private Node&lt;E&gt; node(int index)&#123; int half = size &gt;&gt; 1; //下标小于链表长度一半，从头开始找，否则,从尾部开始找 Node&lt;E&gt; cur; if(index &lt; half)&#123; cur = first; for (int i = 0; i &lt; index; i++) &#123; cur = cur.next; &#125; &#125;else&#123; cur = last; for(int i = (size - 1); i &gt; index; i--)&#123; cur = last.prev; &#125; &#125; return cur; &#125; //检查下标是否越界 private void checkIndex(int index)&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(&quot;下标越界：index &lt; 0 || index &gt;= size&quot;); &#125; &#125; //内部内节点 private class Node&lt;E&gt;&#123; //当前节点元素 E value; //上一个节点 Node&lt;E&gt; prev; //下一个节点 Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next)&#123; this.value = value; this.next = next; &#125; public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)&#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; /** * 重写迭代器，实现迭代遍历元素 */ private class ListItr implements ListIterator&lt;E&gt;&#123; //上一个节点 private Node&lt;E&gt; lastReturned; //下一个节点 private Node&lt;E&gt; next; //下一个节点下标 private int nextIndex; public ListItr(int index) &#123; next = (index == size) ? null : node(index); nextIndex = index; &#125; @Override public boolean hasNext() &#123; return nextIndex &lt; size; &#125; @Override public E next() &#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; lastReturned = next; next = next.next; nextIndex++; return lastReturned.value; &#125; @Override public boolean hasPrevious() &#123; return false; &#125; @Override public E previous() &#123; return null; &#125; @Override public int nextIndex() &#123; return nextIndex; &#125; @Override public int previousIndex() &#123; return 0; &#125; @Override public void remove() &#123; &#125; @Override public void set(E e) &#123; &#125; @Override public void add(E e) &#123; &#125; &#125; &#125; LinkedListTest1234567891011121314151617181920212223242526public class LinkedListTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;计时开始：&quot; + LocalDateTime.now()); LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i=1; i&lt;9; i++) &#123; list.add(i); &#125; System.out.println(&quot;计时结束：&quot; + LocalDateTime.now()); list.addFirst(9); list.add(80); print(list); &#125; public static void print(LinkedList&lt;Integer&gt; list) &#123; for (Object i : list) &#123; System.out.print(i); System.out.print(&quot;,&quot;); &#125; System.out.println(); &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.itcode.net.cn/tags/Java/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-07-26T12:35:13.000Z","updated":"2023-07-29T10:00:11.712Z","comments":true,"path":"posts/d0edc1ed/","link":"","permalink":"https://www.itcode.net.cn/posts/d0edc1ed/","excerpt":"目录与文件 more 12more [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 less 123less [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 head 12345head [OPTION]… FILE…显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行：$ head -5 file1 tail 1234tail [OPTION]… FILE…显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行：$ tail -5 file1 ln","text":"目录与文件 more 12more [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 less 123less [OPTION] FILE…查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 head 12345head [OPTION]… FILE…显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行：$ head -5 file1 tail 1234tail [OPTION]… FILE…显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行：$ tail -5 file1 ln 1234567891011链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（SymbolicLink）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。举例如下，注意ls -l列出文件的硬链接数和字节数：硬链接：touch helloln hello word_h软链接：ln -s hello word_s tree 123这个命令需要下载安装，ubuntu下sudo apt-get install tree按结构树的形状显示目录和文件 wc 12345678利用wc 指令我们可以计算文件的Byte 数、字数、或是列数,若不指定文件名称、或是所给予的文件名为“-”,则wc 指令会从标准输入设备读取数据。wc -l ./*-c 或–bytes 或–chars 只显示Bytes 数。-l 或–lines 只显示列数。-w 或–words 只显示字数。 du 123456789查看某个目录的大小：以M为单位du -hm /home/itcast/test以B为单位du -hb ./*以K为单位,4k的整数倍du -hk ./*总计大小，以M为单位du -hc ./* df 123df查看磁盘使用情况df --block-size=GBdf --block-size=MB 文件属性与用户组 chmod 12345678910111213141516171819202122232425262728293031文字设定法chmod [who] [+|-|=] [mode] 文件名操作对象who可是下述字母中的任一个或者它们的组合：u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。操作符号可以是：+ 添加某个权限。- 取消某个权限。= 赋予给定权限并取消其他所有权限（如果有的话）。设置mode所表示的权限可用下述字母的任意组合：r 可读。w 可写。x 可执行。数字设定法chmod [mode] 文件名0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，user group otherr w x r w x r w x4 2 1 4 2 1 4 2 1 chown 123456789101112131415161718chown [OPTION]… [OWNER:GROUP] FILE…chown [OPTION]… –reference=RFILE FILE…更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户A, 为了让用户A能够存取这个文件，root用户应该把这个文件的属主设为A，否则，用户A无法存取这个文件。OPTION的主要参数：* -R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。* -v 显示chown命令所做的工作。比如把一个文件改为itcast用户和nogroup用户组所有$ sudo chown itcast:nogroup file1注意：* chown需要特权用户才能执行* 一个文件的owner和owning group是没有关联的。一个文件属于用户A，也属于用户组B，并不表示用户A属于用户组B。 chgrp 123456789chgrp [OPTION]… GROUP FILE…chgrp [OPTION]… –reference=RFILE FILE…该命令改变（指定）指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。OPTION的主要参数：-R 递归式地改变指定目录及其下的所有子目录和文件的属组。 查找与检索 find 12345678910111213根据文件名查找find pathname -options [-print -exec -ok -name -type...]在目录中搜索文件，path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。Expression 是find命令接受的表达式，find命令的所有操作都是针对表达式的。一条最常用的find命令－－在当前目录及子目录下查找所有以file开头的文件名。$ find . -name &#x27;file*&#x27;$ find / -name &#x27;vimrc&#x27;$ find ~ -name &#x27;*.c&#x27;$ find /usr/ -name &quot;*tmp*&quot; -exec ls -l &#123; &#125; \\;find ./ -name &quot;*tmp&quot; -ok rm &#123; &#125; \\; grep 1234567891011121314151617根据内容检索grep [options] PATTERN [FILE...]在指定文件中搜索特定的内容，并将含有这些内容的行输出到标准输出。若不指定文件名，则从标准输入读取。[options]部分包含的主要参数：-I：不区分大小写（只适用于单字符）。-h：查询多文件时不显示文件名。-l：查询多文件时只输出包含匹配字符的文件名。-n：显示匹配行及行号。-s：不显示不存在或无匹配文本的错误信息。-v：显示不包含匹配文本的所有行。-R: 连同子目录中所有文件一起查找。比如到系统头文件目录下查找所有包含printf的文件$ grep &#x27;printf&#x27; /usr/include -R 安装卸载软件 更新源服务器列表 1sudo vi /etc/apt/sources.list 更新完服务器列表后需要更新下源 12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 deb包安装 1234567安装deb软件包命令： sudo dpkg -i xxx.deb删除软件包命令： sudo dpkg -r xxx.deb连同配置文件一起删除命令： sudo dpkg -r --purge xxx.deb查看软件包信息命令： sudo dpkg -info xxx.deb查看文件拷贝详情命令： sudo dpkg -L xxx.deb查看系统中已安装软件包信息命令： sudo dpkg -l重新配置软件包命令： sudo dpkg-reconfigure xxx 源码安装 123456789101. 解压缩源代码包2. cd dir3. ./configure检测文件是否缺失，创建Makefile,检测编译环境4. make编译源码，生成库和可执行程序5. sudo make install把库和可执行程序，安装到系统路径下6. sudo make distclean删除和卸载软件 磁盘管理 mount 123456789101112131415161718192021命令格式：mount [-t vfstype] -o options device dir其中：* -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：光盘或光盘镜像：iso9660DOS fat16文件系统：msdosWindows 9x fat32文件系统：vfatWindows NT ntfs文件系统：ntfsMount Windows文件网络共享：smbfsUNIX(LINUX) 文件网络共享：nfs* -o options 主要用来描述设备或档案的挂接方式。常用的参数有：loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备iocharset：指定访问文件系统所用字符集* device 要挂接(mount)的设备。* dir设备在系统上的挂接点(mount point)。 挂接光盘镜像文件 1.从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。 12345#cp /dev/cdrom /home/sunky/mydisk.iso 或#dd if=/dev/cdrom of=/home/sunky/mydisk.iso注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso 2.文件和目录制作成光盘镜像文件，执行下面的命令。 1#mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir ​ 注：这条命令将&#x2F;home&#x2F;sunky&#x2F;mydir目录下所有的目录和文件制作成光盘镜像文件&#x2F;home&#x2F;sunky&#x2F;mydisk.iso，光盘卷标为：mydisk 123456789-r 这个选项能够将文件的uid,gid设为0，因为uid与gid只在制作镜像者本身系统上有效，在其它电脑上没有对应的用户，所以留着也只是无效用户；将所有文件设置为可读。如果文件有可执行的权限的话，将继续保持其可执行的权限。去掉所有文件及文件夹可写权限，因为挂载的光盘镜像本身也就为只读系统，可写权限无意义。其它特殊权限都将被清空。-o 指定被创建的镜像文件名称(包含目录位置)-V 指定光盘标签，就像windows下面挂载系统盘时会显示系统盘的名字一样。-J 或-joliet选项表示使用Joliet格式(可使用unicode储存中文档名）由于在ISO 9660中有一些限制，如字符设置限制,文件名长度限制和目录树深度制。这些规定阻碍了用户复制数据，Joliet是ISO 9660的一个扩展，由Microsoft提出和实现。 3.光盘镜像文件的挂接(mount) 1mkisofs -r -J -V mydisk -o /home/itcast/mydisk.iso /home/itcast/object/ ​ 将&#x2F;home&#x2F;itcast&#x2F;object&#x2F;目录下的内容生成一个叫mydisk.iso的镜像文件保存在目录&#x2F; home&#x2F;itcast&#x2F;下。 1#mkdir /mnt/vcdrom ​ 注：建立一个目录用来作挂接点(mount point) 1#mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom ​ 注：使用&#x2F;mnt&#x2F;vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。 挂载U盘磁盘设备命名一般规则： 在Linux中，设备名称通常都保存在&#x2F;dev里，&#x2F;dev下的文件是特殊的设备文件，和特定 的驱动程序相关联。而这些设备的命名有一定的规则，可以使用“推理”方式把设备名称找 出来。 例如：&#x2F;dev&#x2F; sda1，“sd”是SCSI Device (hd是Hard Disk硬盘，fd是Floppy Disk 软盘)。其中“a”代表第一块硬盘，如果主机上装有4块硬盘，那么他们应该依次编号 sda、sdb、sdc、sdd。而sda1中的“1”代表sda的第一个主分区，sda2代表第二个主分区。 由于一块硬盘的主分区最多允许有4个，因此扩展分区的第一个逻辑分区从sda5开始向后依 次编号。 1.检测存储设备名称 1sudo fdisk -l 2.挂载存储设备sdb1到挂载点&#x2F;mnt目录 12sudo mount /dev/sdb1 /mnt -o utf8可以使U盘内的中文正常显示出来。 3.访问&#x2F;mnt 4.卸载&#x2F;mnt 1sudo umount /mnt umount卸载命令 1sudo umount 挂在点 dddd:拷贝 例1：拷贝光碟(注意，你的光碟是标准的iso9660格式才可以这么做唷！) 1dd if=/dev/cdrom of=cdrom.iso 例2：将文件sfile拷贝到文件dfile中。 1$ dd if=sfile of=dfile 例3：创建一个100M的空文件 1dd if=/dev/zero of=hello.txt bs=100M count=1 &#x2F;dev&#x2F;null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ &#x2F;dev&#x2F;zero,是一个输入设备，你可你用它来初始化文件,从里面读出来的数据都是0。 使用mke2fs命令将常规文件格式化成分区当成文件系统来使用，使用mount借助loop设 备把映像文件当成磁盘分区挂载。 1.以&#x2F;dev&#x2F;zero为输入文件，imagefile为输出创建一个2M大小的文件 1$dd if=/dev/zero of=imagefile bs=2048 count=1024 2.使用mke2fs命令将该文件制作成文件系统。制作期间需输入“y”确认。 1$mke2fs imagefile 3.制作成功后可以将该文件使用mount命令借助loop挂载到&#x2F;mnt下 1$sudo mount -o loop imagefile /mnt 4.可以查看到lost+found缺省目录 1$ls /mnt 5.可以像使用普通磁盘一样，直接在里面创建文件并写入内容。 1$sudo vi hello.c 6.lost+found hello.c 1$ls /mnt 7.在&#x2F;mnt内执行mount命令可以查看该“文件系统”的详细信息。 12$mount如：/home/itcast/mydisk on /mnt type ext2 (rw) 8.可使用umount命令将该“磁盘”卸载。 1$sudo umount /mnt","categories":[{"name":"服务器","slug":"服务器","permalink":"https://www.itcode.net.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.itcode.net.cn/tags/Linux/"}]},{"title":"MAC（M1）配置51单片机环境","slug":"MAC（M1）配置51单片机环境","date":"2023-07-25T14:58:29.000Z","updated":"2023-07-29T05:33:57.680Z","comments":true,"path":"posts/cdcb5503/","link":"","permalink":"https://www.itcode.net.cn/posts/cdcb5503/","excerpt":"安装Rosetta21/usr/sbin/softwareupdate --install-rosetta --agree-to-license 安装Homebrew使用Rosetta2安装Homebrew 123arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;#在安装或更新应用时使用下面的命令即可：arch -x86_64 brew install &lt;package&gt; 编译器sdcc1234arch -x86_64 brew install sdcc#校验是否安装成功sdcc -version 安装CH341驱动为让开发版上的USB转串口模块成功连接到Mac上，我们需要CH341驱动来为Mac系统驱动 下载地址：http://www.wch.cn/download/CH341SER_MAC_ZIP.html","text":"安装Rosetta21/usr/sbin/softwareupdate --install-rosetta --agree-to-license 安装Homebrew使用Rosetta2安装Homebrew 123arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;#在安装或更新应用时使用下面的命令即可：arch -x86_64 brew install &lt;package&gt; 编译器sdcc1234arch -x86_64 brew install sdcc#校验是否安装成功sdcc -version 安装CH341驱动为让开发版上的USB转串口模块成功连接到Mac上，我们需要CH341驱动来为Mac系统驱动 下载地址：http://www.wch.cn/download/CH341SER_MAC_ZIP.html 下载好后将文件解压双击.pkg结尾的文件开始安装，一直点下一步即可完成安装 接下来将单片机连接到Mac上（我使用的是STC89型号的），输入一下命令来检验驱动是否安装成功 1ls /dev/tty.wchusbser* 如果输出一下数据，说明驱动成功 注意⚠️：其中140代表串口号 安装烧录程序stcgal stcgal 是 STC 单片机的下载工具，安装前需确保已提前安装好 python3。 下载stcgal地址： https://github.com/grigorig/stcgal 直接下载源码，解压文件即可，再在终端中cd命令进入解压文件夹（一直按tab键来补全路经） 输入以下两行代码即可安装 12345./setup.py buildsudo ./setup.py install#检测版本信息stcgal -V 调试单片机输入代码在编译器上输入以下代码来用数码管点亮SSPAL（编译器我使用的是CLion），将代码以main.c的保存在桌面上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;8051.h&gt;unsigned char Table[] = &#123;0x6D,0x73,0x77,0x30&#125;; //对应SPAI四个字母void Delay(unsigned int x) //@11.0592MHz下延迟1ms&#123; unsigned char i, j; while(x--) &#123; i = 2; j = 199; do &#123; while (--j); &#125; while (--i); &#125;&#125;void Turn_ON(unsigned int Location ,unsigned int Num1) //点亮&#123; switch(Location) //片选 &#123; case 1:P2_4=1;P2_3=1;P2_2=1;break; case 2:P2_4=1;P2_3=1;P2_2=0;break; case 3:P2_4=1;P2_3=0;P2_2=1;break; case 4:P2_4=1;P2_3=0;P2_2=0;break; case 5:P2_4=0;P2_3=1;P2_2=1;break; case 6:P2_4=0;P2_3=1;P2_2=0;break; case 7:P2_4=0;P2_3=0;P2_2=1;break; case 8:P2_4=0;P2_3=0;P2_2=0;break; &#125; P0=Table[Num1]; //段选 Delay(1); P0=0x00;&#125;void main() //主函数&#123; while(1) &#123; Turn_ON(1,0); Turn_ON(2,0); Turn_ON(3,1); Turn_ON(4,2); Turn_ON(5,3); &#125;&#125; 使用sdcc进行编译 使用终端进入到代码的所在目录下，输入以下代码 1sdcc main.c 就可以发现文件夹中多出了一系列文件 使用stcgal将代码烧录入单片机中 输入以下代码 1stcgal -P stc89 -p /dev/tty.wchusbserial140 -P后参数表示单片机型号，例如我的是STC89，-p后参数表示单片机串口号 注意⚠️：在执行stcgal命令，需要给单片机断电再重新接电才能完成写入过程 点亮了单片机上的SSPAL！","categories":[{"name":"后端","slug":"后端","permalink":"https://www.itcode.net.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.itcode.net.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}],"categories":[{"name":"规划","slug":"规划","permalink":"https://www.itcode.net.cn/categories/%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.itcode.net.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"服务器","slug":"服务器","permalink":"https://www.itcode.net.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"后端","slug":"后端","permalink":"https://www.itcode.net.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.itcode.net.cn/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"https://www.itcode.net.cn/tags/Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://www.itcode.net.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}